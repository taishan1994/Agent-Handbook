# Chapter 2: Routing with PocketFlow

本章节展示了如何使用PocketFlow框架实现路由(Routing)模式。

## 概述

路由模式使Agent能够根据输入内容动态决定执行路径，实现条件逻辑。这种模式允许系统根据不同的请求类型，将其路由到不同的专门处理程序，从而提供更加精准和高效的响应。

## 实现功能

本实现包含以下组件：

1. **RouterNode**: 分析用户请求并决定路由到哪个处理节点
2. **BookingHandlerNode**: 处理与预订相关的请求
3. **InfoHandlerNode**: 处理一般信息查询
4. **UnclearHandlerNode**: 处理无法明确分类的请求
5. **ConditionalFlow**: 根据路由决策执行不同的处理节点

## 高级路由功能

除了基本的LLM路由外，本实现还提供了以下高级路由功能：

1. **EmbeddingRouterNode**: 基于嵌入相似度决定路由
2. **HybridRouterNode**: 结合LLM和嵌入分析决定路由
3. **EmbeddingRoutingFlow**: 基于嵌入的路由流程
4. **HybridRoutingFlow**: 混合路由流程

## 代码结构

```
chapter2/
├── __init__.py          # 章节说明
├── flow.py              # 基本路由模式的核心实现
├── main.py              # 演示基本路由模式的使用
├── embedding_flow.py    # 高级路由模式（嵌入和混合路由）的实现
├── embedding_main.py    # 演示高级路由模式的使用
└── README.md            # 本文件
```

## 使用方法

### 基本路由模式

运行main.py文件来测试基本路由模式：

```bash
cd adp/chapter2
python3 main.py
```

### 高级路由模式

运行embedding_main.py文件来测试高级路由模式：

```bash
cd adp/chapter2
python3 embedding_main.py
```

## 工作原理

### 基本路由模式

1. 用户提交请求到系统
2. RouterNode分析请求并决定路由到哪个处理节点：
   - 'booker': 预订相关的请求
   - 'info': 一般信息查询
   - 'unclear': 不清楚或不适合任一类别
3. 根据路由决策，系统将请求转发到相应的处理节点
4. 处理节点执行特定任务并返回结果
5. 系统将最终结果返回给用户

### 基于嵌入的路由模式

1. 预定义各类别的示例请求并计算其嵌入
2. 对于新请求，计算其嵌入向量
3. 计算新请求与各类别示例的余弦相似度
4. 选择相似度最高的类别作为路由决策

### 混合路由模式

1. 首先使用嵌入相似度进行初步分类
2. 如果相似度足够高，直接使用嵌入结果
3. 否则，使用LLM进行更细致的分析
4. 结合两种方法的结果做出最终路由决策

## 路由模式的优势

- **动态决策**: 根据请求内容动态选择处理路径
- **专门处理**: 每个处理节点专注于特定类型的任务
- **可扩展性**: 易于添加新的处理节点和路由规则
- **灵活性**: 可以轻松调整路由逻辑而无需修改整个系统
- **多种路由策略**: 支持基于LLM、嵌入或混合的路由策略

## 与LangChain实现的对比

本实现使用PocketFlow框架替代了LangChain，主要区别：

- PocketFlow使用Node和Flow类构建工作流
- 节点间连接通过next()方法实现
- 条件路由通过action参数控制
- 更简洁的API和更直观的流程定义

## 扩展建议

1. 添加更多处理节点以支持更多类型的请求
2. 实现更复杂的路由逻辑，如多级路由
3. 添加请求优先级和负载均衡机制
4. 集成外部API以提供更丰富的功能
5. 优化嵌入路由的示例选择和相似度计算
6. 实现自适应路由，根据历史数据优化路由决策