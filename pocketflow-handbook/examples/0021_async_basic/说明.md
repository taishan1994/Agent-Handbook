# PocketFlow 异步基础模块学习文档

## 1. 模块概述

本模块（0021_async_basic）演示了 PocketFlow 框架中异步节点（AsyncNode）和异步工作流（AsyncFlow）的基本使用方法。这是一个简单的食谱推荐应用，展示了如何构建基于异步操作的工作流，包括用户交互、模拟API调用和LLM调用等异步场景。

主要功能：
- 根据用户输入的食材异步获取食谱
- 使用LLM异步推荐最佳食谱
- 处理用户反馈并支持重试机制
- 展示完整的异步工作流构建与执行流程

## 2. 目录结构

```
0021_async_basic/
├── flow.py          # 定义异步工作流结构
├── main.py          # 程序入口，运行工作流
├── nodes.py         # 实现异步节点类
├── utils.py         # 异步工具函数
├── README.md        # 项目说明
├── requirements.txt # 依赖管理
└── 说明.md          # 学习文档（当前文件）
```

## 3. 核心组件详解

### 3.1 异步节点（AsyncNode）

异步节点是 PocketFlow 中处理异步操作的基本单位，与普通 Node 不同，AsyncNode 提供了三个主要的异步方法：

- `prep_async`: 准备阶段，异步获取输入数据
- `exec_async`: 执行阶段，执行主要的异步业务逻辑
- `post_async`: 后续处理阶段，处理执行结果并决定下一个节点

本模块实现了三个核心异步节点：

1. **FetchRecipes 节点**
   - 功能：获取用户输入的食材并异步查询食谱
   - 主要流程：
     - 异步获取用户输入的食材
     - 调用异步函数查询食谱
     - 将结果存储到共享数据中并跳转到推荐节点

2. **SuggestRecipe 节点**
   - 功能：根据获取的食谱列表，使用LLM推荐最佳食谱
   - 主要流程：
     - 从共享数据中获取食谱列表
     - 异步调用LLM获取推荐
     - 存储推荐结果并跳转到审批节点

3. **GetApproval 节点**
   - 功能：获取用户对推荐食谱的反馈
   - 主要流程：
     - 从共享数据中获取推荐结果
     - 异步获取用户反馈（接受或拒绝）
     - 根据反馈决定结束流程或重新推荐

### 3.2 异步工作流（AsyncFlow）

异步工作流用于组织和连接多个异步节点，实现复杂的异步业务流程。主要特点：

- 支持节点间的条件跳转
- 支持循环和分支逻辑
- 使用共享数据（shared store）在节点间传递信息
- 提供异步执行环境

本模块的工作流结构：
```
FetchRecipes → SuggestRecipe → GetApproval
                 ^              |
                 |              |
                 +--------------+  (重试循环)
```

## 4. 异步工具函数

utils.py 提供了三个关键的异步工具函数：

1. **fetch_recipes**
   - 功能：模拟从API异步获取食谱
   - 实现：使用 `asyncio.sleep()` 模拟网络延迟，返回模拟的食谱数据

2. **call_llm_async**
   - 功能：模拟异步LLM调用
   - 实现：使用 `asyncio.sleep()` 模拟LLM处理延迟，返回预设的推荐结果

3. **get_user_input**
   - 功能：异步获取用户输入（关键功能）
   - 实现：使用 `loop.run_in_executor()` 在单独的线程中运行同步的 `input()` 函数，避免阻塞事件循环

## 5. 主程序流程

main.py 展示了如何创建和运行异步工作流：

1. 创建异步工作流实例
2. 初始化共享数据存储
3. 使用 `await flow.run_async()` 异步执行工作流
4. 处理工作流完成后的逻辑

## 6. 异步编程关键点

### 6.1 事件循环管理

- 使用 `asyncio.run()` 启动事件循环
- 所有异步函数都使用 `async/await` 语法
- 注意避免阻塞操作，将同步阻塞操作放在 `run_in_executor()` 中执行

### 6.2 异步函数设计

- 所有需要异步执行的函数都应定义为 `async def`
- 调用异步函数时必须使用 `await` 关键字
- 使用共享数据（shared store）在异步节点间传递数据

### 6.3 错误处理考虑

在实际应用中，异步操作可能会失败，应考虑添加适当的错误处理机制：
- 使用 `try/except` 捕获异步操作中的异常
- 实现超时处理，避免长时间阻塞
- 提供重试机制和错误恢复策略

## 7. 代码优化建议

### 7.1 错误处理增强

当前实现缺少完善的错误处理机制，可以改进：

```python
# 在异步函数中添加错误处理
try:
    recipes = await fetch_recipes(ingredient)
except Exception as e:
    print(f"Error fetching recipes: {e}")
    # 提供备用数据或重试逻辑
```

### 7.2 超时控制

为异步操作添加超时控制，避免长时间阻塞：

```python
# 使用asyncio.wait_for添加超时
recipes = await asyncio.wait_for(fetch_recipes(ingredient), timeout=5.0)
```

### 7.3 并发优化

对于多个独立的异步操作，可以使用 `asyncio.gather()` 实现并发：

```python
# 并发执行多个异步操作
results = await asyncio.gather(
    fetch_recipes(ingredient1),
    fetch_recipes(ingredient2)
)
```

### 7.4 真实API集成

当前使用模拟数据，可以替换为真实API调用：

```python
# 真实的OpenAI异步调用示例
async def call_llm_async(prompt):
    client = AsyncOpenAI()
    response = await client.chat.completions.create(
        model="gpt-3.5-turbo",
        messages=[{"role": "user", "content": prompt}]
    )
    return response.choices[0].message.content.strip()
```

## 8. 与同步工作流的对比

| 特性 | 异步工作流 | 同步工作流 |
|------|------------|------------|
| 执行模式 | 非阻塞，基于事件循环 | 阻塞，顺序执行 |
| I/O操作 | 可并发处理多个I/O | 一次只能处理一个I/O |
| 适用场景 | 网络请求、文件操作等I/O密集型任务 | 计算密集型任务 |
| 性能 | I/O密集型任务性能更佳 | 计算密集型任务性能相当 |
| 代码复杂度 | 稍高，需要处理异步语法 | 较低，逻辑清晰直观 |

## 9. 总结

本模块演示了 PocketFlow 中异步节点和工作流的基本使用方法，通过一个简单的食谱推荐应用展示了异步编程的核心概念和实践技巧。异步编程在处理I/O密集型任务（如网络请求、文件操作、用户交互等）时具有明显优势，可以显著提高程序的并发性能和响应性。

通过学习本模块，您可以掌握：
- 如何创建和使用异步节点（AsyncNode）
- 如何构建和执行异步工作流（AsyncFlow）
- 如何实现异步工具函数
- 如何处理异步编程中的常见问题

这为您在实际项目中应用异步编程提供了坚实的基础。