SWE-bench 不仅单独评估 AI 模型，而是整个“智能体”系统。在这里，“智能体”指的是 AI 模型与其周围软件支架的结合。该支架负责生成输入模型的提示词，解析模型输出以采取行动，并管理交互循环，即模型之前动作的结果被纳入下一个提示。即使使用相同的底层 AI 模型，智能体在 SWE 工作台上的表现也可能因该支架而有显著差异。[SWE-bench-Verified](https://openai.com/index/introducing-swe-bench-verified/) 是 SWE-bench 中一个 500 个问题子集，经过人类审核以确保可解性，因此提供了最清晰的编码智能体性能衡量工具。这就是我们在本文中要参考的基准。

# 实现最先进的技术

## 工具使用智能体

我们在为更新的 Claude 3.5 Sonnet 优化智能体支架时的设计理念是尽可能**赋予语言模型本身更多的控制权**，同时保持脚手架的最小化。智能体有一个提示词，一个用于执行 bash 命令的 Bash 工具，以及一个用于查看和编辑文件及目录的编辑工具。我们将持续采样，直到模型决定完成或超过其 20 万上下文长度。该支架使模型能够自行判断如何解决问题，而非被硬编码在特定的模式或工作流程中。

提示词指了模型的建议方法，但内容不算太长或过于详细，适合这个任务。模型可以自由选择如何从一步移动到另一步，而不是严格且离散的转移。如果你不敏感于token数量，明确鼓励模型产生长响应会有所帮助。

以下代码显示了我们智能体支架的提示：

```python
<uploaded_files>
{location}
</uploaded_files>
I've uploaded a python code repository in the directory {location} (not in /tmp/inputs). Consider the following PR description:

<pr_description>
{pr_description}
</pr_description>

Can you help me implement the necessary changes to the repository so that the requirements specified in the <pr_description> are met?
I've already taken care of all changes to any of the test files described in the <pr_description>. This means you DON'T have to modify the testing logic or any of the tests in any way!

Your task is to make the minimal changes to non-tests files in the {location} directory to ensure the <pr_description> is satisfied.

Follow these steps to resolve the issue:
1. As a first step, it might be a good idea to explore the repo to familiarize yourself with its structure.
2. Create a script to reproduce the error and execute it with `python <filename.py>` using the BashTool, to confirm the error
3. Edit the sourcecode of the repo to resolve the issue
4. Rerun your reproduce script and confirm that the error is fixed!
5. Think about edgecases and make sure your fix handles them as well

Your thinking should be thorough and so it's fine if it's very long.
```

中文对应：

```python
<uploaded_files>
{location}
</uploaded_files>
我已在目录{location}（而非/tmp/inputs）中上传了一个Python代码仓库。请考虑以下PR描述：

<pr_description>
{pr_description}
</pr_description>

你能帮我对仓库进行必要的更改，以满足<pr_description>中规定的要求吗？
我已经处理好了<pr_description>中描述的所有测试文件的变更。这意味着你无需以任何方式修改测试逻辑或任何测试！

你的任务是对{location}目录中的非测试文件进行最小程度的修改，以确保<pr_description>得到满足。

按照以下步骤解决问题：
1. 作为第一步，探索一下仓库以熟悉其结构可能是个好主意。
2. 创建一个脚本来复现错误，并使用BashTool通过`python <filename.py>`执行该脚本，以确认错误
3. 编辑仓库的源代码以解决问题
4. 重新运行复现脚本，确认错误已修复！
5. 考虑边缘情况，并确保你的修复也能处理这些情况

你的思考应该全面，所以即便很长也没关系。
```

模型的第一个工具执行 Bash 命令。该模式很简单，只需在环境中执行命令即可。然而，工具的描述更具分量。它包含了更详细的模型说明，包括逃逸输入、无法上网以及如何在后台运行命令。

接下来，我们展示了 Bash Tool 的规格：

```python
{
   "name": "bash",
   "description": "Run commands in a bash shell\n
* When invoking this tool, the contents of the \"command\" parameter does NOT need to be XML-escaped.\n
* You don't have access to the internet via this tool.\n
* You do have access to a mirror of common linux and python packages via apt and pip.\n
* State is persistent across command calls and discussions with the user.\n
* To inspect a particular line range of a file, e.g. lines 10-25, try 'sed -n 10,25p /path/to/the/file'.\n
* Please avoid commands that may produce a very large amount of output.\n
* Please run long lived commands in the background, e.g. 'sleep 10 &' or start a server in the background.",
   "input_schema": {
       "type": "object",
       "properties": {
           "command": {
               "type": "string",
               "description": "The bash command to run."
           }
       },
       "required": ["command"]
   }
}
```

中文对应：

```text
{
   "name": "bash",
   "description": "在bash shell中运行命令\n
*调用此工具时，“command”参数的内容不需要进行 XML 转义。
*您无法通过此工具访问互联网。
*你确实可以通过 apt 和 pip 访问常见的 Linux 和 Python 软件包镜像。
*状态在命令调用和与用户的对话中保持持久。
*若要查看文件的特定行范围，例如第 10 行到第 25 行，请尝试使用 'sed -n 10,25p /path/to/the/file'。
*请避免使用可能产生大量输出的命令。
*请在后台运行长时间运行的命令，例如 'sleep 10 &' 或在后台启动服务器。
   "input_schema": {
       "type": "object",
       "properties": {
           "command": {
               "type": "string",
               "description": "要运行的bash命令。"
           }
       },
       "required": ["command"]
   }
}
```

模型的第二个工具（编辑工具）要复杂得多，包含模型查看、创建和编辑文件所需的一切。同样，我们的工具描述包含了模型如何使用该工具的详细信息。

我们在各种智能任务中为这些工具的描述和规格投入了大量精力。我们测试了模型，发现模型可能误解规格或使用工具时可能存在的陷阱，然后编辑描述以预防这些问题。我们认为，**设计模型工具界面时应投入更多关注，就像为人类设计工具界面时需要投入大量精力一样。**

以下代码展示了我们编辑工具的描述：

```python
{
   "name": "str_replace_editor",
   "description": "Custom editing tool for viewing, creating and editing files\n
* State is persistent across command calls and discussions with the user\n
* If `path` is a file, `view` displays the result of applying `cat -n`. If `path` is a directory, `view` lists non-hidden files and directories up to 2 levels deep\n
* The `create` command cannot be used if the specified `path` already exists as a file\n
* If a `command` generates a long output, it will be truncated and marked with `<response clipped>` \n
* The `undo_edit` command will revert the last edit made to the file at `path`\n
\n
Notes for using the `str_replace` command:\n
* The `old_str` parameter should match EXACTLY one or more consecutive lines from the original file. Be mindful of whitespaces!\n
* If the `old_str` parameter is not unique in the file, the replacement will not be performed. Make sure to include enough context in `old_str` to make it unique\n
* The `new_str` parameter should contain the edited lines that should replace the `old_str`",
...
```

中文对应：

```text
{
   "name": "str_replace_editor",
   "description": "自定义编辑工具，用于查看、创建和编辑文件\n
* 状态在命令调用和与用户的对话中保持持久\n
* 如果 `path` 是一个文件，`view` 将显示应用 `cat -n` 的结果。如果 `path` 是一个目录，`view` 将列出最多两层深度的非隐藏文件和目录\n
* 如果指定的 `path` 已经作为文件存在，则不能使用 `create` 命令\n
* 如果 `command` 生成的输出较长，它将被截断并标记为 `<response clipped>` \n
* `undo_edit`命令将撤销对`path`路径下文件所做的最后一次编辑\n
\n
使用 `str_replace` 命令的注意事项：
* `old_str`参数必须与原始文件中完全匹配的一行或多行连续行一致。请注意空格！
* 如果 `old_str` 参数在文件中不唯一，则不会执行替换操作。请确保在 `old_str` 中包含足够的上下文信息，使其具有唯一性\n
* `new_str`参数应包含要替换`old_str`的编辑行
...
```

我们提升性能的一种方式是“防错”工具。例如，有时模型在智能体离开根目录后会干扰相对文件路径。为了防止这种情况，我们简单地让工具始终要求绝对路径。

我们尝试了多种不同策略来指定对现有文件的编辑，**字符串替换的可靠性最高**，即模型指定“old_str”替换为“new_str”。只有当“old_str”恰好匹配一次时，才会发生替换。如果匹配数量多或少，模型会被显示适当的错误信息以重新尝试。

我们编辑工具的规格如下：

```
...
   "input_schema": {
       "type": "object",
       "properties": {
           "command": {
               "type": "string",
               "enum": ["view", "create", "str_replace", "insert", "undo_edit"],
               "description": "The commands to run. Allowed options are: `view`, `create`, `str_replace`, `insert`, `undo_edit`."
           },
           "file_text": {
               "description": "Required parameter of `create` command, with the content of the file to be created.",
               "type": "string"
           },
           "insert_line": {
               "description": "Required parameter of `insert` command. The `new_str` will be inserted AFTER the line `insert_line` of `path`.",
               "type": "integer"
           },
           "new_str": {
               "description": "Required parameter of `str_replace` command containing the new string. Required parameter of `insert` command containing the string to insert.",
               "type": "string"
           },
           "old_str": {
               "description": "Required parameter of `str_replace` command containing the string in `path` to replace.",
               "type": "string"
           },
           "path": {
               "description": "Absolute path to file or directory, e.g. `/repo/file.py` or `/repo`.",
               "type": "string"
           },
           "view_range": {
               "description": "Optional parameter of `view` command when `path` points to a file. If none is given, the full file is shown. If provided, the file will be shown in the indicated line number range, e.g. [11, 12] will show lines 11 and 12. Indexing at 1 to start. Setting `[start_line, -1]` shows all lines from `start_line` to the end of the file.",
               "items": {
                   "type": "integer"
               },
               "type": "array"
           }
       },
       "required": ["command", "path"]
   }
}
```

中文对应版本：

```
...
   "input_schema": {
       "type": "object",
       "properties": {
           "command": {
               "type": "string",
               "enum": ["查看", "创建", "字符串替换", "插入", "撤销编辑"],
               "description": "要运行的命令。允许的选项有：`view`、`create`、`str_replace`、`insert`、`undo_edit`。"
           },
           "file_text": {
               "description": "`create`命令的必需参数，包含要创建的文件内容。",
               "type": "string"
           },
           "insert_line": {
               "description": "`insert`命令的必需参数。`new_str`将插入到`path`的`insert_line`行之后。",
               "type": "integer"
           },
           "new_str": {
               "description": "`str_replace`命令的必需参数，包含新字符串。`insert`命令的必需参数，包含要插入的字符串。",
               "type": "string"
           },
           "old_str": {
               "description": "`str_replace`命令的必需参数，包含要替换的`path`中的字符串。",
               "type": "string"
           },
           "path": {
               "description": "文件或目录的绝对路径，例如 `/repo/file.py` 或 `/repo`。",
               "type": "string"
           },
           "view_range": {
               "description": "`view`命令的可选参数，当`path`指向文件时使用。如果未提供该参数，则显示整个文件。如果提供了该参数，则将在指定的行号范围内显示文件，例如[11, 12]将显示第11行和第12行。索引从1开始。设置`[start_line, -1]`将显示从`start_line`到文件末尾的所有行。",
               "items": {
                   "type": "integer"
               },
               "type": "array"
           }
       },
       "required": ["command", "path"]
   }
}
```

## 智能体行为示例

在运行基准测试时，我们以 [SWE-Agent](https://swe-agent.com/) 框架为智能体代码的基础。在下面的日志中，我们将智能体的文本输出、工具调用和工具响应渲染为思维、行动和观察，尽管我们不将模型限制为固定的排序。

下面的代码块将介绍 Sonnet 3.5 解决 SWE 工作台问题的典型案例。

在第一个模块中，你可以看到模型获得的初始提示部分，其中“{pr_description}'被填入了 SWE 工作台任务的真实值。重要的是，该任务包含重现问题的步骤，这将为模型提供有价值的起点进行调查。

```
<uploaded_files>
/repo
</uploaded_files>
I've uploaded a python code repository in the directory /repo (not in /tmp/inputs). Consider the following PR description:

<pr_description>
linear_model.RidgeClassifierCV's Parameter store_cv_values issue
#### Description
Parameter store_cv_values error on sklearn.linear_model.RidgeClassifierCV

#### Steps/Code to Reproduce
import numpy as np
from sklearn import linear_model as lm

#test database
n = 100
x = np.random.randn(n, 30)
y = np.random.normal(size = n)

rr = lm.RidgeClassifierCV(alphas = np.arange(0.1, 1000, 0.1), normalize = True, 
                                         store_cv_values = True).fit(x, y)

#### Expected Results
Expected to get the usual ridge regression model output, keeping the cross validation predictions as attribute.

#### Actual Results
TypeError: __init__() got an unexpected keyword argument 'store_cv_values'

lm.RidgeClassifierCV actually has no parameter store_cv_values, even though some attributes depends on it.
```

中文对应：

```
<uploaded_files>
/repo
</uploaded_files>
我已在目录 /repo（而非 /tmp/inputs）中上传了一个 Python 代码仓库。请考虑以下 PR 描述：

<pr_description>
linear_model.RidgeClassifierCV的参数store_cv_values问题
#### 描述
sklearn.linear_model.RidgeClassifierCV中store_cv_values参数错误

#### 复现步骤/代码
import numpy as np
from sklearn import linear_model as lm

#测试数据库
n = 100
x = np.random.randn(n, 30)
y = np.random.normal(size = n)

rr = lm.RidgeClassifierCV(alphas = np.arange(0.1, 1000, 0.1), normalize = True, 
                                         store_cv_values = True).fit(x, y)

#### 预期结果
预期得到通常的岭回归模型输出，将交叉验证预测结果作为属性保留。

#### 实际结果
类型错误：__init__() 收到了一个意外的关键字参数 'store_cv_values'

lm.RidgeClassifierCV实际上没有store_cv_values参数，尽管某些属性依赖于它。
```

模型会做出响应，并首先使用编辑工具查看存储库结构。你可以在“思考”和“行动”栏目下看到模型的文本输出和工具调用参数，以及在“观察”栏下看到部分工具输出：

```
THOUGHT:
I'll help you implement the changes to satisfy the PR description. Let's follow the steps you outlined.

1. First, let's explore the repo structure:
ACTION (str_replace_editor):
command:
view

path:
/repo

OBSERVATION:
Here's the files and directories up to 2 levels deep in /repo, excluding hidden items:
/repo
/repo/PULL_REQUEST_TEMPLATE.md
/repo/ISSUE_TEMPLATE.md
/repo/sklearn
/repo/sklearn/decomposition
/repo/sklearn/kernel_ridge.py
/repo/sklearn/model_selection
/repo/sklearn/covariance
/repo/sklearn/cluster
/repo/sklearn/base.py
/repo/sklearn/dummy.py
/repo/sklearn/naive_bayes.py
...
```

模型对仓库结构有了更好的理解，它使用编辑工具创建了一个新脚本，用于重现问题并测试修复：

```
THOUGHT:
Based on the repository structure, we'll need to modify the Ridge Classifier in the `sklearn/linear_model` directory.

Let's create a script to reproduce the error:
ACTION (str_replace_editor):
command:
create

path:
/repo/reproduce_error.py

file_text:
import numpy as np
from sklearn import linear_model as lm

#test database
n = 100
x = np.random.randn(n, 30)
y = np.random.normal(size = n)

rr = lm.RidgeClassifierCV(alphas=np.arange(0.1, 1000, 0.1), normalize=True, 
                         store_cv_values=True).fit(x, y)

OBSERVATION:
File created successfully at: /repo/reproduce_error.py
```

模型随后使用 Bash 工具执行其编写的脚本，并成功重现任务中的问题：

```
THOUGHT:
Let's verify that we can reproduce the error:
ACTION (bash):
command:
python3 /repo/reproduce_error.py

OBSERVATION:
Traceback (most recent call last):
  File "/repo/reproduce_error.py", line 10, in <module>
    store_cv_values=True).fit(x, y)
TypeError: __init__() got an unexpected keyword argument 'store_cv_values'

```

此后，模型使用编辑工具修改仓库中的源代码，并重运行脚本以验证更改是否解决了问题：

```
THOUGHT:
The error is reproducible. Looking at the code, I can see that the issue is that while the `RidgeClassifierCV` class inherits from `_BaseRidgeCV`, it fails to pass the `store_cv_values` parameter from its constructor through to the base class constructor.

Let's fix this:
ACTION (str_replace_editor):
command:
str_replace

path:
/repo/sklearn/linear_model/ridge.py

old_str:
    def __init__(self, alphas=(0.1, 1.0, 10.0), fit_intercept=True,
                 normalize=False, scoring=None, cv=None, class_weight=None):
        super(RidgeClassifierCV, self).__init__(
            alphas=alphas, fit_intercept=fit_intercept, normalize=normalize,
            scoring=scoring, cv=cv)
        self.class_weight = class_weight

new_str:
    def __init__(self, alphas=(0.1, 1.0, 10.0), fit_intercept=True,
                 normalize=False, scoring=None, cv=None, class_weight=None,
                 store_cv_values=False):
        super(RidgeClassifierCV, self).__init__(
            alphas=alphas, fit_intercept=fit_intercept, normalize=normalize,
            scoring=scoring, cv=cv, store_cv_values=store_cv_values)
        self.class_weight = class_weight
```

在这个具体例子中，模型工作了12个步骤后决定准备提交。任务测试随后成功运行，验证模型的解决方案解决了问题。有些任务在模型提交解答前需要超过100回合;在其他情况下，模型不断尝试，直到脱离上下文。

