================================================================================
PROBLEM: Two Sum
Difficulty: Easy
Language: python
================================================================================

PROBLEM DESCRIPTION:
Given an array of integers nums and an integer target, return the indices of the two numbers such that they add up to the target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order.

CONSTRAINTS:
- 2 <= nums.length <= 10^4
- -10^9 <= nums[i] <= 10^9
- -10^9 <= target <= 10^9
- Only one valid answer exists

EXAMPLES:
Example 1: {'input': 'nums = [2,7,11,15], target = 9', 'output': '[0,1]', 'explanation': 'nums[0] + nums[1] = 2 + 7 = 9, which equals the target. Hence, the indices 0 and 1 are returned.'}
Example 2: {'input': 'nums = [3,2,4], target = 6', 'output': '[1,2]', 'explanation': 'nums[1] + nums[2] = 2 + 4 = 6, which equals the target. Hence, the indices 1 and 2 are returned.'}
Example 3: {'input': 'nums = [3,3], target = 6', 'output': '[0,1]', 'explanation': 'nums[0] + nums[1] = 3 + 3 = 6, which equals the target. Hence, the indices 0 and 1 are returned.'}

SOLUTION APPROACH:
Use a hash map (dictionary) to store each number and its index as we iterate through the array. For each element, calculate the complement (target - current number). If the complement exists in the hash map, we have found our pair. This approach ensures we only need one pass through the array, making it efficient and straightforward to implement.

ALGORITHM STEPS:
1. Initialize an empty hash map to store number -> index mappings.
2. Iterate through the array with index i and value num.
3. Calculate the complement as target - num.
4. Check if the complement exists in the hash map. If yes, return the current index and the stored index of the complement.
5. If not, add the current number and its index to the hash map and continue.

COMPLEXITY ANALYSIS:
Time Complexity: O(n), where n is the length of the nums array. We iterate through the array once, and each hash map lookup and insertion operation is O(1) on average.
Space Complexity: O(n), due to the hash map storing at most n key-value pairs (each number and its index). In the worst case, all elements are stored before a match is found.

EDGE CASES:
- Array with exactly two elements: The solution handles this naturally since we check for complement after inserting the first element.
- Duplicate values (e.g., [3,3] with target 6): The hash map stores the first occurrence. When the second 3 is processed, its complement (3) is already in the map, so indices [0,1] are returned correctly.
- Negative numbers: The algorithm works because the complement calculation handles negative values correctly.

CODE IMPLEMENTATION:
```python
from typing import List

def solution(nums: List[int], target: int) -> List[int]:
    """
    Finds two numbers in the input list that add up to the target value.
    
    Args:
        nums: List of integers where we need to find two numbers that sum to target
        target: The target sum we are looking for
    
    Returns:
        A list containing the indices of the two numbers that add up to the target.
        The indices are returned in any order, and it is guaranteed that exactly one solution exists.
    """
    # Hash map to store value -> index mapping
    num_to_index = {}
    
    # Iterate through the array with index and value
    for i, num in enumerate(nums):
        # Calculate the complement needed to reach the target
        complement = target - num
        
        # Check if the complement exists in our hash map
        if complement in num_to_index:
            # If found, return the current index and the stored index of complement
            return [num_to_index[complement], i]
        
        # If not found, store the current number and its index
        num_to_index[num] = i
    
    # According to the problem, there is guaranteed to be exactly one solution,
    # so we should never reach here. This is a safety net.
    raise ValueError("No two sum solution found")

```

CODE EXPLANATION:
The solution uses a hash map to store each number and its index as we iterate through the array. For each number, it checks if its complement (target - current number) has already been seen. If so, it returns the indices of both numbers. This approach ensures we find the solution in a single pass through the array.

TEST RESULTS:
Total Tests: 10
Passed: 0
Failed: 10
All Passed: False

FAILED TEST CASES:
Test 1: Example 1: Basic case where the first two elements sum to the target (2 + 7 = 9)
  Input: [2, 7, 11, 15]
  Expected: [0, 1]
  Actual: solution() takes 2 positional arguments but 4 were given

Test 2: Example 2: Middle elements sum to the target (2 + 4 = 6), with non-consecutive indices
  Input: [3, 2, 4]
  Expected: [1, 2]
  Actual: solution() takes 2 positional arguments but 3 were given

Test 3: Example 3: Duplicate values that sum to the target (3 + 3 = 6), testing handling of repeated numbers
  Input: [3, 3]
  Expected: [0, 1]
  Actual: 'int' object is not iterable

Test 4: Negative numbers case: target is -7, and indices 1 and 4 (values -2 and -5) sum to target
  Input: [-1, -2, -3, -4, -5]
  Expected: [1, 4]
  Actual: solution() takes 2 positional arguments but 5 were given

Test 5: Large array with target sum at the extremes: first and last elements (1 + 10 = 11)
  Input: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  Expected: [0, 9]
  Actual: solution() takes 2 positional arguments but 10 were given

Test 6: Boundary case: target is sum of first and last elements (10 + 50 = 60), testing edge indices
  Input: [10, 20, 30, 40, 50]
  Expected: [0, 4]
  Actual: solution() takes 2 positional arguments but 5 were given

Test 7: Mixed positive and negative numbers: target is 1, and indices 1 (0) and 3 (2) sum to 1
  Input: [1, 0, -1, 2, -2, 3, -3]
  Expected: [1, 3]
  Actual: solution() takes 2 positional arguments but 7 were given

Test 8: All elements are the same: target is 10, and any two indices (e.g., 0 and 1) work
  Input: [5, 5, 5, 5, 5]
  Expected: [0, 1]
  Actual: solution() takes 2 positional arguments but 5 were given

Test 9: Large value case: target is 1000000001, testing with large integers within constraints
  Input: [1, 1000000000]
  Expected: [0, 1]
  Actual: 'int' object is not iterable

Test 10: Extreme value case: target is 0, and sum of largest negative and positive values
  Input: [-1000000000, 1000000000]
  Expected: [0, 1]
  Actual: 'int' object is not iterable

FEEDBACK ANALYSIS:
The test failures indicate a fundamental issue with how the function is being called, not with the implementation logic itself. The error messages consistently state 'takes 2 positional arguments but X were given', which suggests that the test runner is passing the entire array as individual arguments (e.g., `solution(1, 2, 3, 4)` instead of `solution([1, 2, 3, 4], target)`). This implies that the function is being invoked incorrectly in the test suite. Additionally, the 'int object is not iterable' error occurs when the function tries to unpack a single integer as an iterable, which happens if the input is not properly structured as a list. The current implementation logic is actually correct and efficient (O(n) time, O(n) space), but the input handling is broken at the call site.

ISSUES FOUND:
- {'issue': 'Function is being called with individual array elements as separate arguments instead of a list and target as two arguments', 'location': 'Test case invocation (not in function code)', 'severity': 'high'}
- {'issue': 'The function expects a list of integers and a target integer, but the test cases are passing the array elements as separate positional arguments', 'location': 'Test case setup', 'severity': 'high'}
- {'issue': "The 'int object is not iterable' error suggests that somewhere in the test or function, a single integer is being treated as an iterable, likely due to incorrect input parsing", 'location': 'Test input processing', 'severity': 'high'}

FIX SUGGESTIONS:
- {'suggestion': 'Ensure that the test cases pass the input as a list and the target as a separate argument, not as individual elements', 'code_change': 'Change test calls from `solution(2, 7, 11, 15, 9)` to `solution([2, 7, 11, 15], 9)`'}
- {'suggestion': 'Verify that the test runner correctly constructs the input arguments: a list for nums and an integer for target', 'code_change': 'In test cases, use: `solution([3, 2, 4], 6)` instead of `solution(3, 2, 4, 6)`'}
- {'suggestion': 'Add input validation to the function to catch incorrect types early and provide clearer error messages', 'code_change': 'Add type checks at the start of the function: `if not isinstance(nums, list): raise TypeError("nums must be a list")`'}

Iterations: 4
